# 异步通知



## 硬件中断

中断是处理器提供的一种异步机制，我们配置好中断以后就可以让处理器去处理其他的事情了，当中断发生以后会触发我们事先设置好的中断服务函数，在中断服务函数中做具体的处理。



## 信号

信号可以理解为在软件层面上模拟了中断机制，也叫软中断信号。==**驱动程序可以主动向应用程序发送信号来通知应用程序“自己”可以访问了。**==

阻塞、非阻塞、异步通知，这三种是针对不同的场合提出来的不同的解决方法，各有优劣。

异步通知的核心就是信号，在 arch/xtensa/include/uapi/asm/signal.h 文件中定义了 Linux 所支持的所有信号，这些信号如下所示：

```c
#define SIGHUP 1 	/* 终端挂起或控制进程终止 */
#define SIGINT 2 	/* 终端中断(Ctrl+C 组合键) */
#define SIGQUIT 3 	/* 终端退出(Ctrl+\组合键) */
#define SIGILL 4 	/* 非法指令 */
#define SIGTRAP 5 	/* debug 使用，有断点指令产生 */
#define SIGABRT 6 	/* 由 abort(3)发出的退出指令 */
#define SIGIOT 6 	/* IOT 指令 */
#define SIGBUS 7 	/* 总线错误 */
#define SIGFPE 8 	/* 浮点运算错误 */
#define SIGKILL 9 	/* 杀死、终止进程 */		常用
#define SIGUSR1 10 	/* 用户自定义信号 1 */
#define SIGSEGV 11 	/* 段违例(无效的内存段) */
#define SIGUSR2 12 	/* 用户自定义信号 2 */
#define SIGPIPE 13 	/* 向非读管道写入数据 */
#define SIGALRM 14 	/* 闹钟 */
#define SIGTERM 15 	/* 软件终止 */
#define SIGSTKFLT 16 /* 栈异常 */
#define SIGCHLD 17 	/* 子进程结束 */
#define SIGCONT 18 	/* 进程继续 */
#define SIGSTOP 19 	/* 停止进程的执行，只是暂停 */	常用
#define SIGTSTP 20 	/* 停止进程的运行(Ctrl+Z 组合键) */
#define SIGTTIN 21 	/* 后台进程需要从终端读取数据 */
#define SIGTTOU 22 	/* 后台进程需要向终端写数据 */
#define SIGURG 23 /* 有"紧急"数据 */
#define SIGXCPU 24 /* 超过 CPU 资源限制 */
#define SIGXFSZ 25 /* 文件大小超额 */
#define SIGVTALRM 26 /* 虚拟时钟信号 */
#define SIGPROF 27 /* 时钟信号描述 */
#define SIGWINCH 28 /* 窗口大小改变 */
#define SIGIO 29 /* 可以进行输入/输出操作 */		常用
#define SIGPOLL SIGIO
/* #define SIGLOS 29 */
#define SIGPWR 30 /* 断点重启 */
#define SIGSYS 31 /* 非法的系统调用 */
#define SIGUNUSED 31 /* 未使用信号 */
```

除了SIGKILL（9）和SIGSTOP（19），其他信号都可以忽略不处理。



## 驱动中的异步通知

若要使用异步通知，那么驱动程序就要做下面的操作：

1. **创建一个fasync_struct 结构体指针变量**
   1. **实现file_operations中的fasync函数**

2. **当设备可读或可写时，使用`kill_fasync`函数向应用程序发信号**



### 驱动中的异步通知初始化

首先我们需要在驱动程序中定义一个 fasync_struct 结构体指针变量， fasync_struct 结构体内容如下：

```c
struct fasync_struct {
    spinlock_t fa_lock;
    int magic;
    int fa_fd;
    struct fasync_struct *fa_next;
    struct file *fa_file;
    struct rcu_head fa_rcu;
};
```



如果要使用异步通知，需要在设备驱动中实现 file_operations 操作集中的 fasync 函数，此函数格式如下所示：

```c
int (*fasync) (int fd, struct file *filp, int on)
    
    
--fd：文件描述符，用于标识用户空间中打开的文件。内核通过该描述符找到对应的文件结构。
--filp：文件对象指针，表示内核内部管理的已打开文件实例。包含文件状态、偏移量等信息。
--on：控制标志：
	on = 1：用户空间进程请求启用异步通知（通过 F_SETOWN 和 FASYNC 命令）。
	on = 0：用户空间进程请求禁用异步通知。
```

fasync 函数里面一般通过调用 fasync_helper 函数来初始化前面定义的 fasync_struct 结构体指针， fasync_helper 函数原型如下：

```c
int fasync_helper(int fd, struct file * filp, int on, struct fasync_struct **fapp)
```

**fasync 函数例子：**

```C
int dev_fasync (int fd, struct file * filp, int on)
{
    struct dev* dev = (struct dev*)filp->private_data;
    return fasync_helper(fd,filp,on,&dev->key[0].fasync);
   
}
```



### 驱动关闭异步通知

当应用程序停止访问驱动程序时，驱动程序需要关闭异步通知。**在file_operations中的release函数**中执行以下操作：

```c
static int xxx_release(struct inode *inode, struct file *filp)
{
	return xxx_fasync(-1, filp, 0); /* 删除异步通知 */
}
```





### 驱动程序向应用程序发信号

当设备可以访问的时候，驱动程序需要向应用程序发出信号，相当于产生“中断”。 kill_fasync函数负责发送指定的信号， kill_fasync 函数原型如下所示：

````c
void kill_fasync(struct fasync_struct **fp, int sig, int band)
    
--fp：要操作的 fasync_struct。
--sig： 要发送的信号。
--band： 可读时设置为 POLL_IN，可写时设置为 POLL_OUT。
````



## 应用中的异步通知

**如果我们要在应用程序中使用信号，那么就必须设置信号所使用的信号处理函数，在应用程序中使用 signal 函数来设置指定信号的处理函数， signal 函数原型如下所示：**

```c
sighandler_t signal(int signum, sighandler_t handler)
    
--signum：要处理的信号
--handler：信号处理函数	typedef void (*sighandler_t)(int)
--返回值：设置成功的话返回信号的前一个处理函数，设置失败的话返回 SIG_ERR。
```



应用程序需要做的操作如下：

1. 使用 signal 函数来设置信号的处理函数。

2. 使用 fcntl(fd, F_SETOWN, getpid())将本应用程序的进程号告诉给内核。

3. 使用如下两行程序开启异步通知：

   ```c
   flags = fcntl(fd, F_GETFL); /* 获取当前的进程状态 */
   fcntl(fd, F_SETFL, flags | FASYNC); /* 开启当前进程异步通知功能 */
   ```

   



## 阻塞、非阻塞和异步通知

- 阻塞IO是等待设备被可访问
- 非阻塞IO 是查询设备是否可访问
- 异步通知时设备通知应用可以访问





## Linux下printf函数不加\n就不能输出相关的内容

unix上标准输入输出都是带有缓存的，一般是行缓存。

对于标准输出，需要输出的数据并不是直接输出到终端上，而是首先缓存到某个地方，当遇到行刷新标志或者该缓存已满的情况下，才会把缓存的数据显示到终端设备上。

ANSI C中定义换行符\n可以认为是行刷新标志。所以，printf函数没有带\n是不会自动刷新输出流，直至缓存被填满。

解决方案：

- 方案1: 在printf里加\n

- 方案2: **在printf后面调用fflush(stdout)函数来刷新标准输出缓冲区，把输出缓冲区里的东西打印到标准输出设备上 。**
